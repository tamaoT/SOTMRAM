import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
import os
from scipy.stats import norm
from scipy.fftpack import fft, ifft
from sklearn.cluster import MiniBatchKMeans
import pandas as pd

devices = ["LTMA80B_3"]
temperature=[]
count_switching_all = []
mag_all = []
bias_all = []
# R_SOT = 520
for d in range(len(devices)):
    device = devices[d]

    base_dir = r'\\oslo\share\133-SPINTEC\133.2-Equipes\133.2.1-MRAM\133.2.1.2-People\Tamao\VGSOT_vs_T'
    # base_dir = 'E:/MARGUIRITE/IVdc_SOT'
    folder_path = f'{base_dir}/{device}/'

    
        
    file_paths = []
    
    for file_name in os.listdir(folder_path):
        file_path = os.path.join(folder_path, file_name)
        if os.path.isfile(file_path) and file_name.endswith('.dat'):
            file_paths.append(file_path)            
            
    No_of_files = len(file_paths)

    results = []

    for i in range(No_of_files):
        
        loops = 100  
        filename = file_paths[i]
        basename = os.path.basename(filename)
        T = float((basename.split('_T')[1]).split('.dat')[0])
        T = round(T)
        temperature.append(T)
        # if T < 280:
        #     continue
        Bip = float((basename.split('_B')[1]).split('_Bias')[0])*1000
        Bip = round(Bip, 1)
        mag_all.append(Bip)
        # if Bip < -52 or Bip > -46:
        #     continue
        MTJ_bias = float((basename.split('_Bias')[1]).split('_T')[0])
        bias_all.append(MTJ_bias)
    
        # df = pd.read_csv(filename, sep=r'\s+', skiprows=1, dtype=float)
        # data = df.to_numpy()
        df = pd.read_csv(filename, sep=r'\s+', skiprows=1, on_bad_lines='skip')
        data = df.to_numpy(dtype=float)

        
        # if data.shape[1]>2:
        #     SOT_bias = 100e-6
        #     if device == 'JTMA80B_2':
        #         SOT_bias = 10e-6
        #     noisy_R_SOT = 2*SOT_bias*data[:1000,2]/(2*SOT_bias+(0.025/data[:1000,1]))
            
        #     try:
        #         # Apply FFT
        #         fft_values = fft(noisy_R_SOT)
        #         threshold = 0.02 * np.max(np.abs(fft_values))
        #         filtered_fft = np.where(np.abs(fft_values) > threshold, fft_values, 0)
                
        #         # Inverse FFT
        #         filtered_R_SOT = np.real(ifft(filtered_fft))
        #         R_SOT = np.median(filtered_R_SOT)
        #         data[:,1] = data[:,1]-R_SOT/2
        #     except IndexError:
        #         R_SOT = np.nan
        # elif data.shape[1]<3:
        #     R_SOT = np.nan
            
        # Apply K-Means clustering with 2 clusters (Parallel & Anti-Parallel states)
        R_MTJ = data[:,1]
        kmeans = MiniBatchKMeans(n_clusters=2, random_state=42)
        _ = kmeans.fit_predict(R_MTJ.reshape(-1, 1))
        
        # クラスタ中心（低抵抗がRp、つまりP状態）
        centers = kmeans.cluster_centers_.flatten()
        sorted_indices = np.argsort(centers)  # 小さい方 = Rp

        # ラベルを再マッピングして、必ず label == 0 が Rp
        original_labels = kmeans.labels_
        label_map = np.zeros_like(kmeans.labels_)
        label_map[kmeans.labels_ == sorted_indices[0]] = 0  # Rp
        label_map[kmeans.labels_ == sorted_indices[1]] = 1  # Rap

        labels = label_map

        # Extract cluster centers (Rp and Rap)
        Rp, Rap = np.sort(kmeans.cluster_centers_.flatten())
        TMR = ((Rap-Rp)/Rp)*100
        if Rap > 1000000:
            print("Skipping Rap:", Rap)
            continue
        elif Rp < 3000:
            print("Skipping Rp:", Rp)
            continue 
        if TMR < 20:
            print("Skipping TMR:", TMR)
            continue
    
        
        subdata = np.array_split(data[:,:2], loops, axis=0) 
        All_parameters = []
        count_switching = []
        # plt.figure()
        for l in range(loops):
        
            x = subdata[l][:,0]
            y = subdata[l][:,1]
            dy = np.diff(y)
            dx = x[1:]
            
            # plt.plot(dx, dy, '.')
            # plt.plot(x, y, '.-')

            thresold_up = (Rap-Rp)/2
            thresold_down = (Rp-Rap)/2
            positive_peaks_y = np.where(dy > thresold_up)
            negative_peaks_y = np.where(dy < thresold_down)
            positive_peaks_x = dx[positive_peaks_y]
            negative_peaks_x = dx[negative_peaks_y]
            


            
            count_switching.append([positive_peaks_x,negative_peaks_x])
             
            if len(positive_peaks_x) >= 1 and len(negative_peaks_x) >= 1:
                
                Isw_p2ap = positive_peaks_x[np.argmin(np.abs(positive_peaks_x))]
                Isw_ap2p = negative_peaks_x[np.argmin(np.abs(negative_peaks_x))]
                
                # if np.sign(Isw_p2ap) == np.sign(Isw_ap2p):
                #     print("Skipping Isw:", Isw_p2ap, Isw_ap2p)
                #     continue
            else:
                print("Skipping Isw = 0:", positive_peaks_x, negative_peaks_x)
                continue
            
            
            plt.plot(x, y, '.-', color = 'black')
               
    
            column = (Bip, Isw_p2ap, Isw_ap2p)
            All_parameters.append(column)
    
        plt.axhline(Rp, color='blue', linestyle='--', label=f"Rp: {Rp:.2f} Ω")
        plt.axhline(Rap, color='red', linestyle='--', label=f"Rap: {Rap:.2f} Ω")
        plt.xlabel('I_SOT (uA)')
        plt.ylabel('R_MTJ (Ohm)')
        plt.legend()
        plt.title(device+', Bx =' + str(Bip) +' mT, T = ' + str(T)+ 'K, ' + "Bias="+ str(MTJ_bias))
        plt.show()
            
        count_switching_all.append(count_switching)
        All_parameters = np.array(All_parameters).astype(float)
        
        
        # try:
        #     All_Isw_p2ap = All_parameters[:,1]
        #     All_Isw_ap2p = All_parameters[:,2]
    
        # except IndexError:
        # # If an IndexError occurs, assign Rp_mean as nan
        #     column = (Bip, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, R_SOT, MTJ_bias, T)
            
        #     results.append(column)
        #     continue   
        
        
        # if All_Isw_p2ap.shape[0]<10 or All_Isw_ap2p.shape[0]<10:
        #     continue
        # # All_Isw = [All_Isw_p2ap,All_Isw_ap2p]
        # # for q in range(2):
        # #     data = All_Isw[q]
        # #     X = data.reshape(-1, 1)
        # #     # Fit a Gaussian Mixture Model with 2 components
        # #     gmm = GaussianMixture(n_components=2, random_state=42)
        # #     gmm.fit(X)
            
        # #     # Get the component with the highest weight
        # #     largest_cluster = np.argmax(gmm.weights_)
        # #     labels = gmm.predict(X)
            
        # #     All_Isw[q] = data[labels == largest_cluster]
            
        # loops_p2ap = len(All_Isw_p2ap)
        # loops_ap2p = len(All_Isw_ap2p)
            
    
        # if np.mean(All_Isw_p2ap) > np.mean(All_Isw_ap2p):
        #     unique_Isw_p2ap = np.unique(subdata[l][:,0][subdata[l][:,0]>0])
        #     unique_Isw_ap2p = np.unique(subdata[l][:,0][subdata[l][:,0]<0])
        # elif np.mean(All_Isw_p2ap) < np.mean(All_Isw_ap2p):
        #     unique_Isw_p2ap = np.unique(subdata[l][:,0][subdata[l][:,0]<0])
        #     unique_Isw_ap2p = np.unique(subdata[l][:,0][subdata[l][:,0]>0])
         
      
                
        # counts_Isw_p2ap = np.array([np.sum(All_Isw_p2ap == val) for val in unique_Isw_p2ap])
        # Plot_Isw_p2ap = np.column_stack((unique_Isw_p2ap, counts_Isw_p2ap))
        # Plot_Isw_p2ap = Plot_Isw_p2ap[np.argsort(np.abs(Plot_Isw_p2ap[:, 0]))]
        # Plot_Isw_p2ap[:,1] = (np.cumsum(Plot_Isw_p2ap[:,1]))/loops_p2ap
        
        # counts_Isw_ap2p = np.array([np.sum(All_Isw_ap2p == val) for val in unique_Isw_ap2p])
        # Plot_Isw_ap2p = np.column_stack((unique_Isw_ap2p, counts_Isw_ap2p))
        # Plot_Isw_ap2p = Plot_Isw_ap2p[np.argsort(np.abs(Plot_Isw_ap2p[:, 0]))]
        # Plot_Isw_ap2p[:,1] = (np.cumsum(Plot_Isw_ap2p[:,1]))/loops_ap2p
        
        # # Define the normal distribution CDF function
        # def normal_cdf(x, mu, sigma):
        #     if np.mean(x) > 0:
        #         return norm.cdf(x, loc=mu, scale=sigma)
        #     elif np.mean(x) < 0:
        #         return 1 - norm.cdf(x, loc=mu, scale=sigma)
            
        
    
        # plt.plot(Plot_Isw_ap2p[:,0], Plot_Isw_ap2p[:,1], '.', label = 'AP to P')
        # plt.plot(Plot_Isw_p2ap[:,0], Plot_Isw_p2ap[:,1], '.', label = 'P to AP')
        
        # attempt = 0
        # while attempt < 10:
        #     try:
        #         guess1 = (round(np.mean(All_Isw_ap2p),2), np.random.uniform(20,200))
        #         popt1, pcov1 = curve_fit(normal_cdf, Plot_Isw_ap2p[:,0], Plot_Isw_ap2p[:,1], p0=guess1, method='trf')
        #         Ic_ap2p, sigma1 = popt1
        #         x_fit1 = np.linspace(min(Plot_Isw_ap2p[:,0]), max(Plot_Isw_ap2p[:,0]), 100)
        #         plt.plot(x_fit1, normal_cdf(x_fit1, Ic_ap2p, sigma1))
                
        #         break
        #     except RuntimeError:
        #         attempt +=1
           
        # attempt = 0
        # while attempt < 10:
        #     try:    
        #         guess2 = (round(np.mean(All_Isw_p2ap),2), np.random.uniform(20,200))
        #         popt2, pcov2 = curve_fit(normal_cdf, Plot_Isw_p2ap[:,0], Plot_Isw_p2ap[:,1], p0=guess2, method='trf')
        #         Ic_p2ap, sigma2 = popt2
        #         x_fit2 = np.linspace(min(Plot_Isw_p2ap[:,0]), max(Plot_Isw_p2ap[:,0]), 100)
        #         plt.plot(x_fit2, normal_cdf(x_fit2, Ic_p2ap, sigma2))
                
        #         break
        #     except RuntimeError:
        #         attempt +=1
    
        # loops_updated = min(loops_p2ap,loops_ap2p)
        # plt.title(device+', MTJ_bias =' + str(Bip) +' mT, T = ' + str(T)+ 'K, loops = ' + str(loops_updated))
        # plt.xlabel('Isw (uA)')
        # plt.ylabel('Psw')
        # plt.legend()
        # ax = plt.gca()
        # fit_parameters = f"Ic = {Ic_p2ap:.3f} uA, {Ic_ap2p:.3f} uA"
        # plt.text(0.7, 0.5, fit_parameters , fontsize=12, transform=ax.transAxes, ha='right', va='top')
        # plt.show()
    
        # Ic = (np.abs(Ic_p2ap)+np.abs(Ic_ap2p))/2
        
        # Rp_mean = Rp
        # Rap_mean = Rap
        # TMR_mean = TMR
        # column = (Bip, Ic_p2ap, Ic_ap2p, Ic, Rp_mean, Rap_mean, TMR_mean, R_SOT, T)
        # # column = (Bip, Ic_ap2p, Ic_p2ap, Ic, sigma1, sigma2, Delta, T)
        # results.append(column)
           
    results = np.array(results).astype(float)
    
    parameters = results
    
    # parameters = parameters[np.lexsort((parameters[:, 0], parameters[:, -1]))]
        
    
    header = 'Bip Ic_p2ap Ic_ap2p Ic Rp_mean Rap_mean TMR_mean R_SOT MTJ_bias T'
    # np.savetxt(save_directory + f'{device}_SOTdc.txt', parameters, header=header, comments='')

# %%
bias_list = sorted(list(set(bias_all)))
print(bias_list)
# %%
import matplotlib.cm as cm
from matplotlib.collections import LineCollection
from matplotlib.lines import Line2D

norm = plt.Normalize(-0.8, 0.8)
cmap = cm.spring

fig = plt.figure()
ax = fig.add_subplot(111)
I_positive_all = []
eI_positive_all = []
I_negative_all = []
eI_negative_all = []

for j in range(No_of_files):
    if mag_all[j] > 0:
        n_positive = []
        n_negative = []
        I_positive = []
        I_negative = []
        count_switching = count_switching_all[j]
        for i in range(loops):
            n_positive.append(len(count_switching[i][0]))
            n_negative.append(len(count_switching[i][1]))
            I_positive.append(np.average(count_switching[i][0]))
            I_negative.append(np.average(count_switching[i][1]))
            # I_positive.append(np.std(count_switching[i][0]))
        I_positive_all.append(np.average(I_positive))
        eI_positive_all.append(np.std(I_positive))
        I_negative_all.append(np.average(I_negative))
        eI_negative_all.append(np.std(I_negative))
        for k in range(len(bias_list)):
            if bias_all[j] == bias_list[k]:

                # plt.errorbar(temperature[j], np.average(I_positive), yerr =  np.std(I_positive), capsize=5, fmt='o', markersize=5, ecolor=cm.spring(k/10.0), markeredgecolor = cm.spring(k/10.0), color=cm.spring(k/10.0))
                # plt.errorbar(temperature[j], np.average(I_negative), yerr =  np.std(I_negative), capsize=5, fmt='o', markersize=5, ecolor=cm.spring(k/10.0), markeredgecolor = cm.spring(k/10.0), color=cm.spring(k/10.0))
                # # Only label the first appearance to avoid duplicated legend entries
                if j == 0:
                    label_pos = 'P → AP'
                    label_neg = 'AP → P'
                else:
                    label_pos = label_neg = None

                # plt.errorbar(temperature[j], np.average(I_positive), yerr =  np.std(I_positive), 
                #             capsize=5, fmt='o', markersize=5, 
                #             ecolor=cm.spring(k/10.0), markeredgecolor = cm.spring(k/10.0), color=cm.spring(k/10.0), label=label_pos)

                plt.errorbar(temperature[j], np.average(I_negative), yerr =  np.std(I_negative), 
                            capsize=5, fmt='o', markersize=5, 
                            ecolor=cm.spring(k/10.0), markeredgecolor = cm.spring(k/10.0), color=cm.spring(k/10.0),  label=label_neg)
                legend_elements = [
    #Line2D([], [], linestyle=None, color = "w", label='↑ P → AP'),
    Line2D([], [], linestyle=None, color = "w", label='↓ AP → P')]

plt.title("{}, Bx > 0".format(devices[0]))
plt.xlabel("T (K)")
plt.ylabel("Isot (uA)")
plt.xlim(0,310)


# plt.ylim(0,1100)
sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
sm.set_array([]) 
cbar = plt.colorbar(sm, ax=ax)
ax.legend(handles=legend_elements, loc='center', frameon=False)
plt.show()
#%%

fig = plt.figure()
ax = fig.add_subplot(111)
I_positive_all = []
eI_positive_all = []
I_negative_all = []
eI_negative_all = []
for j in range(No_of_files):
    if mag_all[j] < 0:
        n_positive = []
        n_negative = []
        I_positive = []
        I_negative = []
        count_switching = count_switching_all[j]
        
        for i in range(loops):
            n_positive.append(len(count_switching[i][0]))
            n_negative.append(len(count_switching[i][1]))
            I_positive.append(np.average(count_switching[i][0]))
            I_negative.append(np.average(count_switching[i][1]))
            # I_positive.append(np.std(count_switching[i][0]))
        I_positive_all.append(np.average(I_positive))
        eI_positive_all.append(np.std(I_positive))
        I_negative_all.append(np.average(I_negative))
        eI_negative_all.append(np.std(I_negative))
        for k in range(len(bias_list)):
            if bias_all[j] == bias_list[k]:
                plt.errorbar(temperature[j], np.average(I_positive), yerr =  np.std(I_positive), capsize=5, fmt='o', markersize=5, ecolor=cm.spring(k/10.0), markeredgecolor = cm.spring(k/10.0), color=cm.spring(k/10.0))
                plt.errorbar(temperature[j], np.average(I_negative), yerr =  np.std(I_negative), capsize=5, fmt='o', markersize=5, ecolor=cm.spring(k/10.0), markeredgecolor = cm.spring(k/10.0), color=cm.spring(k/10.0))
                legend_elements = [
    Line2D([], [], linestyle=None, color = "w", label='↓ P → AP'),
    Line2D([], [], linestyle=None, color = "w", label='↑ AP → P')]
plt.title("{}, Bx < 0".format(devices[0]))
plt.xlabel("T (K)")
plt.ylabel("Isot (uA)")
plt.xlim(0,310)
#plt.ylim(-1100,1100)
sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
sm.set_array([])  
cbar = plt.colorbar(sm, ax=ax)
ax.legend(handles=legend_elements, loc='center', frameon=False)
plt.show()
